library(foreign)
panel <- read.dta("http://dss.princeton.edu/training/Panel101.dta")
newton <- function(f, x0, tol = 1e-5, n = 1000) {
require(numDeriv) # Package for computing f'(x)
for (i in 1:n) {
dx <- genD(func = f, x = x0)$D[1] # First-order derivative f'(x0)
x1 <- x0 - (f(x0) / dx) # Calculate next value x1
if (abs(x1 - x0) < tol) {
res <- paste("Root approximation is ", x1, " in ", i, " iterations")
return(res)
}
# If Newton-Raphson has not yet reached convergence set x1 as x0 and continue
x0 <- x1
}
print('Too many iterations in method')
}
func2 <- function(x) {
x^15 - 2
}
newton(func2, 1)
newton(func2, 2)
newton(func2, 12)
df1 <- df(xx = 1:4,
y = c(1,0,1,0))
df1 <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df1
wtf <- function(x) c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(wtf, x = x)) %*% wtf(x) ##new x value
delta <- x - as.matrix(xx)
}
wtf <- function(x) c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x) - solve(jacobian(wtf, x = x)) %*% wtf(x)
delta <- x - as.matrix(xx)
}
library(numDeriv)
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x) - solve(jacobian(wtf, x = x)) %*% wtf(x) ##new x value
delta <- x - as.matrix(xx)
}
x
as.matrix(x)
library(numDeriv)
wtf <- function(x) c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x) - solve(jacobian(wtf, x = x)) %*% wtf(x)
delta <- x - as.matrix(xx)
}
library(numDeriv)
wtf <- function(x) c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x)-solve(jacobian(wtf, x = x))%*%wtf(x)
delta <- x - as.matrix(xx)
}
library(numDeriv)
wtf <- function(x) c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x)-solve(jacobian(wtf, x = x))%*%wtf(x)
delta <- x-as.matrix(xx)
}
solve(jacobian(wtf, x = x))
solve(jacobian(wtf, x))
jacobian(wtf, x)
View(wtf)
wtf <- function(x){
c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
}
View(wtf)
library(numDeriv)
wtf <- function(x){
c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
}
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x)-solve(jacobian(wtf, x))%*%wtf(x)
delta <- x-as.matrix(xx)
}
library(numDeriv)
wtf <- function(x){
c(sum(df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx))),
sum(df$xx * (df$y - exp(x[1] + x[2] * df$xx)/ (1 + exp(x[1] + x[2] * df$xx)))))
}
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x
x <- as.matrix(x)-solve(jacobian(wtf, xx))%*%wtf(x)
delta <- x-as.matrix(xx)
}
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
set.seed(1)
n <- 500
x = rnorm(n, 0,2)
sigma <- 1/(1+exp(-x))
plot(sigma ~ x, col ="blue", cex.axis = 0.7)
#Creating random data
set.seed(1)
n <- 500
xx = rnorm(n) # this is our x
z = -2 + 3 * xx
#Probability is defined by a logistic function
p = 1 / (1 + exp(-z))
#Remember Bernoulli distribution defines Y as 1 or 0
#Bernoulli is the special case of the binomial distribution with size = 1
y = rbinom(n, size = 1, prob = p)
#And we create our data
df1 <-  data.frame(y, xx)
head(df1)
View(df1)
logis <- glm(y ~ x, data = data, family = binomial)
logis <- glm(y ~ xx, data = df1, family = binomial)
summary(logis)
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
df <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
df <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
df1 <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df1
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
#Creating random data
set.seed(1)
n <- 500
xx = rnorm(n) # this is our x
z = -2 + 3 * xx
#Probability is defined by a logistic function
p = 1 / (1 + exp(-z))
#Remember Bernoulli distribution defines Y as 1 or 0
#Bernoulli is the special case of the binomial distribution with size = 1
y = rbinom(n, size = 1, prob = p)
#And we create our data
df1 <-  data.frame(y, xx)
head(df1)
logis <- glm(y ~ xx, data = df1, family = binomial)
summary(logis)
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
delta2 <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta2)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta2 <- x - as.matrix(xx)
}
df1 <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df1
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
delta <- matrix(1:2,nrow = 2)
x <- array(c(-2,3))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
#Creating random data
set.seed(1)
n <- 500
xx = rnorm(n) # this is our x
z = -2 + 3 * xx
#Probability is defined by a logistic function
p = 1 / (1 + exp(-z))
#Remember Bernoulli distribution defines Y as 1 or 0
#Bernoulli is the special case of the binomial distribution with size = 1
y = rbinom(n, size = 1, prob = p)
#And we create our data
df1 <-  data.frame(y, xx)
head(df1)
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(-2,3))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
df1 <- data.frame(xx = 1:4,
y = c(1,0,1,0))
df1
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(2,-1))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
rm(list=ls())
#Creating random data
set.seed(1)
n <- 500
xx = rnorm(n) # this is our x
z = -2 + 3 * xx
#Probability is defined by a logistic function
p = 1 / (1 + exp(-z))
#Remember Bernoulli distribution defines Y as 1 or 0
#Bernoulli is the special case of the binomial distribution with size = 1
y = rbinom(n, size = 1, prob = p)
#And we create our data
df1 <-  data.frame(y, xx)
head(df1)
logis <- glm(y ~ xx, data = df1, family = binomial)
summary(logis)
func.u <- function(x) c(sum(df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx))),
sum(df1$xx * (df1$y - exp(x[1] + x[2] * df1$xx)/ (1 + exp(x[1] + x[2] * df1$xx)))))
delta <- matrix(1:2,nrow = 2)
x <- array(c(-2,3))
while(abs(sum(delta)) > 0.0001){
xx <- x ##current x value
x <- as.matrix(x) - solve(jacobian(func.u, x = x)) %*% func.u(x) ##new x value
delta <- x - as.matrix(xx)
}
x
knitr::include_graphics("png/RN.png")
